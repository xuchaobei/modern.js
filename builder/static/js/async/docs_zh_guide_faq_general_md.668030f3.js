(self.webpackChunkwebpack=self.webpackChunkwebpack||[]).push([["docs_zh_guide_faq_general_md"],{73244:function(e,r,n){"use strict";Object.defineProperty(r,"__esModule",{value:!0});!function(e,r){for(var n in r)Object.defineProperty(e,n,{enumerable:!0,get:r[n]})}(r,{frontmatter:function(){return s},toc:function(){return t},title:function(){return l},default:function(){return a}});var d=n("12151"),i=n("21447");let s=void 0,t=[{id:"modernjs-builder-和-modernjs-的关系",text:"Modern.js Builder 和 Modern.js 的关系？",depth:2},{id:"builder-能否用于构建工具库或组件库",text:"Builder 能否用于构建工具库或组件库？",depth:2},{id:"builder-是否会接入-turbopack",text:"Builder 是否会接入 Turbopack？",depth:2},{id:"builder-是否会接入-vite",text:"Builder 是否会接入 Vite？",depth:2}],l="通用类问题";function u(e){let r=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p"},(0,i.useMDXComponents)(),e.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(r.h1,{id:"通用类问题",children:[(0,d.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#通用类问题",children:"#"}),"通用类问题"]}),"\n",(0,d.jsxs)(r.h2,{id:"modernjs-builder-和-modernjs-的关系",children:[(0,d.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#modernjs-builder-和-modernjs-的关系",children:"#"}),"Modern.js Builder 和 Modern.js 的关系？"]}),"\n",(0,d.jsx)(r.p,{children:"Modern.js 的构建能力是基于 Modern.js Builder 实现的。"}),"\n",(0,d.jsx)(r.p,{children:"在开发 Modern.js 的过程中，我们把 Builder 作为独立的模块进行设计，并明确划分 Builder 与 Modern.js 的职责界限。\n因此，Builder 可以脱离 Modern.js 框架使用，被单独应用于其他框架或场景。"}),"\n",(0,d.jsxs)(r.h2,{id:"builder-能否用于构建工具库或组件库",children:[(0,d.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#builder-能否用于构建工具库或组件库",children:"#"}),"Builder 能否用于构建工具库或组件库？"]}),"\n",(0,d.jsx)(r.p,{children:"Builder 专注于解决 Web 应用构建场景，我们不推荐你使用 Builder 来构建工具库或组件库。"}),"\n",(0,d.jsxs)(r.p,{children:["如果需要构建工具库或组件库，推荐使用 ",(0,d.jsx)(r.a,{href:"https://modernjs.dev/module-tools",target:"_blank",rel:"noopener noreferrer",children:"Modern.js 模块工程方案"}),"。"]}),"\n",(0,d.jsxs)(r.h2,{id:"builder-是否会接入-turbopack",children:[(0,d.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#builder-是否会接入-turbopack",children:"#"}),"Builder 是否会接入 Turbopack？"]}),"\n",(0,d.jsxs)(r.p,{children:["Builder 已经在对接 Rspack，并且目前 Turbopack 仅支持在 Next.js 中使用，因此 Builder 暂时没有接入 ",(0,d.jsx)(r.a,{href:"https://turbo.build/pack",target:"_blank",rel:"noopener noreferrer",children:"Turbopack"})," 的计划。"]}),"\n",(0,d.jsxs)(r.h2,{id:"builder-是否会接入-vite",children:[(0,d.jsx)(r.a,{className:"header-anchor","aria-hidden":"true",href:"#builder-是否会接入-vite",children:"#"}),"Builder 是否会接入 Vite？"]}),"\n",(0,d.jsxs)(r.p,{children:[(0,d.jsx)(r.a,{href:"https://vitejs.dev/",target:"_blank",rel:"noopener noreferrer",children:"Vite"})," 是一个非常优秀的工具，但 Builder 的目标是使用 Rust Bundler 替换 webpack，Rust Builder 能提供极致的编译速度，同时能保持开发环境和生产环境的打包行为一致。"]}),"\n",(0,d.jsx)(r.p,{children:"Builder 会聚焦于从 webpack 演进至 Rust Builder 的过程，因此不会接入 Vite。"})]})}var a=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.useMDXComponents)(),e.components);return r?(0,d.jsx)(r,Object.assign({},e,{children:(0,d.jsx)(u,e)})):u(e)}}}]);